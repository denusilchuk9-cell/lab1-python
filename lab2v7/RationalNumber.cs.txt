using System;

namespace lab2v8
{
    public class RationalNumber
    {
        private int numerator;
        private int denominator;

        public int Numerator
        {
            get => numerator;
            set => numerator = value;
        }

        public int Denominator
        {
            get => denominator;
            set
            {
                if (value == 0) throw new ArgumentException("Знаменник не може бути 0!");
                denominator = value;
            }
        }

        public RationalNumber(int numerator, int denominator)
        {
            Numerator = numerator;
            Denominator = denominator;
            Simplify();
        }

        private static int GCD(int a, int b)
        {
            a = Math.Abs(a); b = Math.Abs(b);
            while (b != 0) { int t = a % b; a = b; b = t; }
            return a == 0 ? 1 : a;
        }

        private void Simplify()
        {
            int g = GCD(Numerator, Denominator);
            Numerator /= g;
            Denominator /= g;
            if (Denominator < 0) { Numerator = -Numerator; Denominator = -Denominator; }
        }

        // Перевантажені оператори
        public static RationalNumber operator +(RationalNumber a, RationalNumber b)
            => new RationalNumber(a.Numerator * b.Denominator + b.Numerator * a.Denominator,
                                  a.Denominator * b.Denominator);

        public static RationalNumber operator -(RationalNumber a, RationalNumber b)
            => new RationalNumber(a.Numerator * b.Denominator - b.Numerator * a.Denominator,
                                  a.Denominator * b.Denominator);

        public static RationalNumber operator *(RationalNumber a, RationalNumber b)
            => new RationalNumber(a.Numerator * b.Numerator, a.Denominator * b.Denominator);

        public static RationalNumber operator /(RationalNumber a, RationalNumber b)
        {
            if (b.Numerator == 0) throw new DivideByZeroException("Ділення на нуль!");
            return new RationalNumber(a.Numerator * b.Denominator, a.Denominator * b.Numerator);
        }

        public static bool operator ==(RationalNumber a, RationalNumber b)
        {
            if (ReferenceEquals(a, b)) return true;
            if (a is null || b is null) return false;
            return a.Numerator * b.Denominator == b.Numerator * a.Denominator;
        }

        public static bool operator !=(RationalNumber a, RationalNumber b) => !(a == b);

        public override bool Equals(object obj) => obj is RationalNumber r && this == r;
        public override int GetHashCode() => (Numerator, Denominator).GetHashCode();
        public override string ToString() => $"{Numerator}/{Denominator}";

        // Індексатор: 0 -> numerator, 1 -> denominator
        public int this[int index]
        {
            get => index switch { 0 => Numerator, 1 => Denominator, _ => throw new IndexOutOfRangeException("Індекс 0 або 1") };
            set
            {
                if (index == 0) Numerator = value;
                else if (index == 1)
                {
                    if (value == 0) throw new ArgumentException("Знаменник не може бути 0!");
                    Denominator = value;
                    Simplify();
                }
                else throw new IndexOutOfRangeException("Індекс 0 або 1");
            }
        }
    }
}

